# regOct
an implementation of an ordered octree system

## Design principles
0. Provide an effective, comprehensive storage medium for cubic, three-dimensional data.
1. The order in which the commands are stored in the file imply the position at which they are executed.
2. State checks within the octree are linear and processor unintensive.
3. The Octree is a self-contained system. All information regarding the octree is stored in the file.

## File Format (.onc)
The **.onc** format (octree encrypted code) is the file format of choice for this code. In its current state (**v. 0.2.0**) data is stored as standard text and, as such, can be read, understood and written by regular mortals. 

### Important Notice:

1. As regOct, and its data format, store raw values (currently strings), it is a highly abstracted data format. What the values represent is entirely dependant on the software interpreting it, so caution must be applied when loading a file. This also means that a program can have two seperate and unique regOct instances, where the same values are used differently. This problem is partially solved through use of Vartags.
2. All theoretical points in regOct are equidistant. If, for whatever reason, complex 3d data must be stored, then that must be done so as an attribute. This is because the highly ordered nature of the format allows for high-speed get()-calls (the get() code is ridiculously short).

## Visualisation WIP
Integrated with the package will be a handy-dandy pyGame-based octree visualiser, that utilises state-of-the-art rect() calls :trollface:.

1. As regOct, and its data format, store raw values (currently strings), it is a highly abstracted data format. What the values represent is entirely dependant on the software interpreting it, so caution must be applied when loading a file. This also means that a program can have two seperate and unique regOct instances, where the same values are used differently. As such, a regOct instance **MUST** be bound to an enum.
2. All theoretical points in regOct are equidistant. If, for whatever reason, complex 3d data must be stored, then that must be done so as an attribute. This is because the highly ordered nature of the format allows for high-speed get()-calls (the get() code is ridiculously short).

## Visualisation WIP
Integrated with the package <del>is</del> :trollface: will be a handy-dandy pyGame-based octree visualiser, that utilises state-of-the-art rect() calls.

## Implementation specifics

### VARTAGS
TL;DR:
Vartags are how the interpreter knows what data goes where. They must be defined in a dict when loading a regOct.
 
Specifically, there are two dicts that use vartags. One is generated by the file loader, which correlates read data with a Vartag, and the other one is defined by the user (the "setup" dict) correlating the vartag to a variable name.
As data is read, it is added to an internal dict, along with a Vartag, which is given to the target. The target then loads said data to a variable defined in the second dict.
Example:
``` python
>>> setup = {"python_is_awesome":"0x0", "trollfaces":"0x1", "spanish_inquisition":"0xC"}
>>> data = {"0x0":True, "0xC":"unexpected", "0x1":1}
>>> correlate(setup, data)
python_is_awesome = True
trollfaces = 1
spanish_inquisition = unexpected
>>> setup = {"python_is_awesome":"0x0", "trollfaces":"0x1", "spanish_inquisition":"0x2"}
>>> data = {"0x0":True, "0x2":"unexpected", "0x1":1}
>>> correlate(setup, data)
```
creates the attribute constellation:
``` python 
def method(*args):
    python_is_awesome = True
    trollfaces = 1
    spanish_inquisition = "unexpected"
```

### Implicit Attributes WIP
TL;DR:
Implicit Attributes aggregate values from the branches underneath them. They should have boolean-like enum values.

As the name implies, these attributes are not determined by what is directly read from the file, but rather what its subjects' values are.
Therefore, there should only be three possible states per implicit attribute: True, False, Both/Inconclusive. It is recommended that these values be Enums.
Unlike Explicit Attributes, these are not restricted to leaves, and are optional. After the octree is completed, it recursively checks all branches and updates their implicit attributes. 

## And now for something completely different
![**no one expects the spanish inquisition**](https://static.wikia.nocookie.net/montypython/images/f/ff/Spanish_Inquisition.jpg/revision/latest?cb=20180629171423)
